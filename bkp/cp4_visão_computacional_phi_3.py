# -*- coding: utf-8 -*-
"""CP4_VISÃO_COMPUTACIONAL_PHI_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WQGVT20yuR2sRoa_AilyzYnNBBdq-c_A

Professor: José Maia<br>
Alunos:<br>
Arthur Coutinho Santos - RM 97804<br>
Guilherme Garcia Paschoalinoto - RM 99221<br>
Luis Gustavo Dias da Silva - RM 99589<br>
Nicolas Felippe Gonçalves - RM 98244
"""

from google.colab import drive
drive.mount('/content/drive')

"""## ***Install Required Libraries***"""

!pip install numpy==1.24.4 Pillow==10.3.0 Requests==2.31.0 torch==2.3.0 torchvision==0.18.0 transformers==4.40.2

!pip install accelerate

pip install openai

pip install openai==0.28

!mkdir my_models
!mkdir my_models/phi_3_vision

"""## ***Imports***"""

import os
from transformers import AutoModelForCausalLM, AutoProcessor
from PIL import Image
import requests
import json
import time
import openai

"""## ***Import Phi-3-vision model***"""

model_id = "microsoft/Phi-3-vision-128k-instruct"

model = AutoModelForCausalLM.from_pretrained(model_id,
                                             cache_dir="/content/my_models/phi_3_vision",
                                             device_map="cuda",
                                             trust_remote_code=True,
                                             torch_dtype="auto",
                                             _attn_implementation="eager")

# Carregar o modelo e processador
processor = AutoProcessor.from_pretrained(model_id, trust_remote_code=True)

# Caminho para as imagens
image_folder = "/content/drive/MyDrive/FIAP/2TIAR/VISAO_COMPUTACIONAL/CP_4/imagens_dataset"
output_json_path = "/content/drive/MyDrive/FIAP/2TIAR/VISAO_COMPUTACIONAL/CP_4/output.json"

# Função para estruturação de dados que foram criados pelo PHI-3
def structure_and_refine_text(response_text):
    # Conectea API do ChatGPT
    openai.api_key = "api-key chatgpt"

    # chamada de formatação com a API do ChatGPT
    prompt = f"""
    Dado o seguinte texto:

    {response_text}

    Estruture este texto em JSON com os seguintes campos:
    - description: Uma breve descrição da roupa.
    - items: Itens superiores, inferiores, sapatos e acessórios.
    - colors: As cores predominantes na roupa.
    - occasions: Ocasiões apropriadas para usar a roupa.

    Certifique-se de que a descrição seja clara e sem repetições.
    """

    response = openai.ChatCompletion.create(
      model="gpt-4",
      messages=[
          {"role": "system", "content": "Você é um assistente que ajuda a estruturar dados de descrições de roupas."},
          {"role": "user", "content": prompt}
      ]
    )

    return response['choices'][0]['message']['content']

# Função para processar as imagens e criar as Tags das mesmas
def process_image(image_path):
    try:
        image = Image.open(image_path)
    except Exception as e:
        print(f"Erro ao carregar a imagem: {e}")
        return None

    # Criar o prompt específico para extração de informações
    messages = [
        {"role": "user", "content": "<|image_1|>\nDescreva a roupa nesta imagem, incluindo itens superiores, itens inferiores, possíveis lugares para usar e cores."}
    ]

    prompt = processor.tokenizer.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)
    inputs = processor(prompt, images=[image], return_tensors="pt").to("cuda:0")

    # Configuração da geração
    generation_args = {
        "max_new_tokens": 500,
        "temperature": 0.0,
        "do_sample": False,
    }

    # Geração da resposta
    generate_ids = model.generate(**inputs, eos_token_id=processor.tokenizer.eos_token_id, **generation_args)
    generate_ids = generate_ids[:, inputs['input_ids'].shape[1]:]
    response = processor.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]

    # Usar ChatGPT para estruturar e ajustar o texto
    structured_response = structure_and_refine_text(response)

    return structured_response

# Processar todas as imagens na pasta e salvar as saídas em uma variável
results = {}
for image_file in os.listdir(image_folder):
    if image_file.endswith(('.png', '.jpg', '.jpeg')):
        image_path = os.path.join(image_folder, image_file)
        print(image_path)
        description = process_image(image_path)
        results[image_file] = description

# Salvar o resultado em um arquivo JSON
with open(output_json_path, 'w') as json_file:
    json.dump(results, json_file, indent=4)

print(f"Resultados salvos em {output_json_path}")

import json

# Carregar o arquivo JSON para leitura
json_path = "/content/drive/MyDrive/FIAP/2TIAR/VISAO_COMPUTACIONAL/CP_4/output.json"
with open(json_path, 'r') as file:
    data = json.load(file)

import re
from collections import OrderedDict
# Foi verificado que o algoritmo fez a leitura dos arquivos de forma aleatória sendo necessário colocar em ordem os nomes para melhor identificação
# Função para extrair o número do nome do arquivo
def extract_number(image_name):
    match = re.search(r'\d+', image_name)
    return int(match.group()) if match else 0

# Ordenar o JSON pelas chaves com base nos números
ordered_data = OrderedDict(sorted(data.items(), key=lambda x: extract_number(x[0])))

# Mostrar os dados de forma estruturada
for image_name, details_str in ordered_data.items():
    details = json.loads(details_str)  # Converte a string JSON em um dicionário
    print(f"Imagem: {image_name}")
    print(f"Descrição: {details['description']}")
    print("Items:")
    for item, description in details['items'].items():
        print(f"  {item.capitalize()}: {description}")

    print("Cores:")
    colors = details['colors']

    if isinstance(colors, dict):
        for color_category, color_values in colors.items():
            if isinstance(color_values, list):
                print(f"  {color_category.capitalize()}: {', '.join(color_values)}")
            else:
                print(f"  {color_category.capitalize()}: {color_values}")
    elif isinstance(colors, list):
        print(f"  Colors: {', '.join(colors)}")

    # Verifica se "occasions" é uma string ou uma lista
    occasions = details['occasions']
    if isinstance(occasions, list):
        print(f"Ocasions: {', '.join(occasions)}")
    else:
        print(f"Ocasions: {occasions}")

    print("\n" + "-"*50 + "\n")

# Salvar novo arquivo JSON ordenado em um novo arquivo
ordered_json_path = "/content/drive/MyDrive/FIAP/2TIAR/VISAO_COMPUTACIONAL/CP_4/output_ordered.json"
with open(ordered_json_path, 'w') as file:
    json.dump(ordered_data, file, indent=4, ensure_ascii=False)